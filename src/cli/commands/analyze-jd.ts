/**
 * Analyze Job Description Command
 *
 * Fetches job description from URL and performs deep analysis
 */

import { spawn } from 'child_process';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

import chalk from 'chalk';
import { Command } from 'commander';
import ora from 'ora';

import { scrapeJobDescription, type JobDescriptionData } from '../lib/jd-scraper';

interface AnalysisResult {
  technical_skills: string[];
  leadership_skills: string[];
  domain_expertise: string[];
  required_skills: string[];
  nice_to_have_skills: string[];
  ats_keywords: string[];
  keyword_importance: Record<string, number>;
  keyword_frequency: Record<string, number>;
}

/**
 * Call Python analyzer
 */
async function callPythonAnalyzer(description: string): Promise<AnalysisResult> {
  return new Promise((resolve, reject) => {
    const pythonProcess = spawn('python3', [
      '-c',
      `
import sys
import json
sys.path.insert(0, 'src/python')
from jd_analyzer.analyzer import analyze_job_description

text = sys.stdin.read()
result = analyze_job_description(text)
print(json.dumps(result))
`,
    ]);

    let output = '';
    let errorOutput = '';

    pythonProcess.stdout.on('data', (data) => {
      output += data.toString();
    });

    pythonProcess.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });

    pythonProcess.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`Python analyzer failed: ${errorOutput}`));
        return;
      }

      try {
        const result = JSON.parse(output);
        resolve(result);
      } catch (error) {
        reject(new Error(`Failed to parse analysis result: ${error}`));
      }
    });

    // Send description to Python process
    pythonProcess.stdin.write(description);
    pythonProcess.stdin.end();
  });
}

/**
 * Format date for filename
 */
function formatDate(date: Date): string {
  const isoString = date.toISOString();
  return isoString.split('T')[0] || 'unknown-date'; // YYYY-MM-DD
}

/**
 * Sanitize company and role names for filename
 */
function sanitizeForFilename(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

/**
 * Generate analysis report in Markdown
 */
function generateMarkdownReport(jd: JobDescriptionData, analysis: AnalysisResult): string {
  const report = `# Job Description Analysis

**Company:** ${jd.company}
**Position:** ${jd.position}
**URL:** ${jd.url}
**Analyzed:** ${new Date().toLocaleString() || 'N/A'}

---

## Technical Skills Required

${analysis.technical_skills.length > 0 ? analysis.technical_skills.map((skill) => `- ${skill}`).join('\n') : '_No technical skills identified_'}

---

## Leadership & Soft Skills

${analysis.leadership_skills.length > 0 ? analysis.leadership_skills.map((skill) => `- ${skill}`).join('\n') : '_No leadership skills identified_'}

---

## Domain Expertise

${analysis.domain_expertise.length > 0 ? analysis.domain_expertise.map((skill) => `- ${skill}`).join('\n') : '_No domain expertise identified_'}

---

## Required Skills

${analysis.required_skills.length > 0 ? analysis.required_skills.map((skill) => `- ${skill}`).join('\n') : '_No required skills explicitly listed_'}

---

## Nice-to-Have Skills

${analysis.nice_to_have_skills.length > 0 ? analysis.nice_to_have_skills.map((skill) => `- ${skill}`).join('\n') : '_No nice-to-have skills explicitly listed_'}

---

## ATS Keywords (Prioritized)

${analysis.ats_keywords
  .slice(0, 20)
  .map(
    (keyword, idx) =>
      `${idx + 1}. **${keyword}** (importance: ${(analysis.keyword_importance[keyword] || 0).toFixed(2)})`
  )
  .join('\n')}

---

## Keyword Frequency Analysis

| Keyword | Frequency | Importance |
|---------|-----------|------------|
${Object.entries(analysis.keyword_frequency)
  .slice(0, 15)
  .map(
    ([keyword, freq]) =>
      `| ${keyword} | ${freq} | ${(analysis.keyword_importance[keyword] || 0).toFixed(2)} |`
  )
  .join('\n')}

---

## Original Job Description

${jd.description}

---

## Requirements (Extracted)

${jd.requirements.length > 0 ? jd.requirements.map((req, idx) => `${idx + 1}. ${req}`).join('\n') : '_No requirements extracted_'}

---

## Benefits (Extracted)

${jd.benefits.length > 0 ? jd.benefits.map((benefit, idx) => `${idx + 1}. ${benefit}`).join('\n') : '_No benefits extracted_'}

---

_Generated by Resume Toolkit - ${new Date().toISOString()}_
`;

  return report;
}

/**
 * Analyze job description from URL
 */
export async function analyzeJobDescription(url: string): Promise<void> {
  const spinner = ora('Analyzing job description...').start();

  try {
    // Step 1: Scrape job description
    spinner.text = 'Fetching job description from URL...';
    const jdData = await scrapeJobDescription(url);
    spinner.succeed(
      `Fetched job description for ${chalk.cyan(jdData.position)} at ${chalk.cyan(jdData.company)}`
    );

    // Step 2: Analyze with Python
    spinner.start('Analyzing job requirements and keywords...');
    const analysis = await callPythonAnalyzer(jdData.description);
    spinner.succeed('Analysis complete');

    // Step 3: Generate report
    spinner.start('Generating analysis report...');
    const report = generateMarkdownReport(jdData, analysis);

    // Step 4: Save to file
    const date = formatDate(new Date());
    const company = sanitizeForFilename(jdData.company);
    const role = sanitizeForFilename(jdData.position);
    const outputDir = join(process.cwd(), 'applications', `${date}-${company}-${role}`);
    const outputPath = join(outputDir, 'jd-analysis.md');

    await mkdir(outputDir, { recursive: true });
    await writeFile(outputPath, report, 'utf-8');

    spinner.succeed(`Analysis saved to ${chalk.green(outputPath)}`);

    // Display summary
    console.log('\n' + chalk.bold('Analysis Summary:'));
    console.log(`${chalk.blue('Technical Skills:')} ${analysis.technical_skills.length}`);
    console.log(`${chalk.blue('Leadership Skills:')} ${analysis.leadership_skills.length}`);
    console.log(`${chalk.blue('ATS Keywords:')} ${analysis.ats_keywords.length}`);
    console.log(`${chalk.blue('Top Keywords:')} ${analysis.ats_keywords.slice(0, 5).join(', ')}`);
    console.log(`\n${chalk.green('âœ“')} Full analysis saved to: ${outputPath}\n`);
  } catch (error) {
    spinner.fail('Failed to analyze job description');

    if (error instanceof Error) {
      console.error(chalk.red('Error:'), error.message);

      // Provide helpful error messages
      if (error.message.includes('403')) {
        console.error(
          chalk.yellow(
            '\nTip: Some job boards block automated access. Try using a different URL or manually copying the job description.'
          )
        );
      } else if (error.message.includes('404')) {
        console.error(
          chalk.yellow('\nTip: The job posting may have been removed or the URL is incorrect.')
        );
      }
    }

    throw error;
  }
}

/**
 * Create analyze-jd command
 */
export const analyzeJdCommand = new Command('analyze-jd')
  .description('Analyze job description from URL and extract keywords')
  .argument('<url>', 'Job description URL (LinkedIn, Greenhouse, Lever, Indeed, Workday)')
  .action(async (url: string) => {
    try {
      await analyzeJobDescription(url);
    } catch (error) {
      process.exit(1);
    }
  });
